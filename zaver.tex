\chapter*{Záver}
\label{chap:conclusion}
\addcontentsline{toc}{chapter}{\textbf{Záver}}

Bakalárska práca sa zaoberala rôznymi možnosťami testovania náhodnosti. Ukázali sme si niektoré nevýhody štatistických testov a predstavili sme nástroj EACirc, ktorý používa na testovanie náhodnosti úplne iný prístup ako štatistické testy. 

EACirc používa na testovanie náhodnosti tzv. obvody. Tieto obvody sa vytvárajú automaticky a na ich vytváranie sa používa samovzdelávací genetický algoritmus. Ten funguje tak, že postupne, počas celého behu vylepšuje tento obvod tak, aby mal čo najlepšiu úspešnosť v určovaní náhodnosti. Tieto obvody sú v skutočnosti graf, ktorý obsahuje uzly a v konečnom dôsledku fungujú ako funkcia, ktorá rozlišuje medzi náhodnými dátami a výstupom z kryptografickej funkcie. Táto funkcia funguje tak, že uzlami grafu prechádzajú dáta a tie s nimi manipulujú a posielajú ich ďalším uzlom. Po tom čo dáta prejdú všetkými uzlami EACirc získa výsledok a vyhlasuje, či sú dáta náhodné.

Cieľom tejto práce bolo rozšíriť framework EACirc tak, aby bolo možné v rámci jeho uzlov vykonávať náhodný kus inštrukcií, ktoré pochádzajú z programu, ktorý je napísaný v jazyku Java. Tento cieľ bol splnený tým spôsobom, že sa vytvorili tzv. JVM uzly, ktoré sa pridali ako ďalší typ uzlov k už existujúcim. Tieto uzly sa v súčasnej implementácií dajú jednoducho použiť. Jedinou požiadavkou je špecifikovať v konfiguračnom súbore názov bytecodu a povoliť použitie JVM uzlov. Dokonca sa dajú použiť aj v kombinácií s bežnými uzlami, teda v rámci jedného obvodu sa použijú aj bežné uzly a zároveň aj JVM uzly.

Rozdiel medzi bežnými a JVM uzlami je taký, že bežné uzly vykonávajú len jednoduchú funkcionalitu, napríklad operáciu \textit{AND} alebo podobné operácie, medzi všetkými vstupmi. Na druhej strane pri vykonávaní JVM uzla sa automaticky zavolá JVM simulátor, ktorý z uzla získa parametre a následne podľa nich vykoná náhodnú časť inštrukcií z dopredu načítaného bytecodu. Tieto inštrukcie manipulujú zo vstupmi a po vykonaní všetkých inštrukcií, dostávame výsledok, ktorý určuje či sú dáta náhodné alebo sú výstupom z kryptografickej funkcie. Tieto uzly majú nasledujúce výhody.
\begin{myItemize}
	\item Pomocou JVM uzlov je genetika schopná vytvoriť zložitejšie obvody.
	\item Na odlíšenie výstupu z kryptografickej funkcie od náhodných dát môžeme používať bytecode získaný priamo z tejto funkcie.
\end{myItemize}
Avšak s týmto prístupom sa spájajú aj niektoré nevýhody. Napríklad:
\begin{myItemize}
	\item jednou z nich je dĺžka výpočtu, ktorá je oproti bežným uzlom mnohonásobne dlhšia. 
	\item Je zložité implementovať celú funkcionalitu Java virtual machine, pretože obsahuje množstvo inštrukcií a prácu z množstvom dátových typov. Keďže v našom JVM simulátore nepodporujeme niektoré dátové typy, napríklad polia alebo objekty, tak sa niektoré inštrukcie automaticky preskakujú.
	\item Okrem toho, že je možnosť vytvorenia zložitých obvodov výhoda, môže to byť v niektorých prípadoch aj nevýhoda. Dôvodom je to, že keďže sa vytvárajú zložitejšie obvody, aj genetika potrebuje vykonať zložitejšiu činnosť aby takýto zložitý obvod vylepšila a teda sa jej to nemusí vždy podariť. 
\end{myItemize}

Okrem rozšírenia EACircu o JVM simulátor bolo mojou úlohou aj vykonať experimenty a porovnať výsledky s výsledkami, ktoré boli získané zo štandardného EACircu. Z výsledkov, ktoré boli prezentované v kapitole 4 vyplýva, že EACirc s novým typom uzlov dosahuje podobné výsledky ako EACirc s bežnými uzlami, avšak vo väčšine prípadoch s trochu menšou istotou. To znamená, že zo všetkých behov, ktoré boli spustené bolo viac úspešných práve tých, ktoré používali bežné uzly. Avšak to nemusí znamenať, že EACirc s JVM uzlami nemá žiadnu perspektívu. Dalo by sa nájsť ešte veľa experimentov, v ktorých by mohli JVM uzly prekvapiť.

Ďalšou úlohou bolo overiť, či je pre genetiku výhoda, a teda či je EACirc úspešnejší, ak sa používajú v uzloch inštrukcie z kryptografickej funkcie, ktorej dáta sa práve testujú. Z výsledkov vyplýva, že toto tvrdenie je nepravdivé, pretože napríklad výsledky pre funkciu \textit{Decim} jasne ukazujú, že bytecode z tejto funkcie mal najhoršiu úspešnosť zo všetkých testovaných bytecodov. Dokonca zvládol rozoznať o jednu rundu menej ako všetky ostatné prípady.

Pre niektoré kombinácie som spustil aj výpočty s 300000 generáciami. Tieto výpočty dopadli lepšie ako tie na 30000 generáciách, čo je však očakávané, pretože dlhšie vylepšovanie obvodu by malo logicky vyústiť k nájdeniu úspešnejších obvodov. Veľmi zaujímavé rozšírenie tohoto experimentu, čo sa týka počtu generácií, by bolo nájsť taký počet generácií, pri ktorom by sa EACirc už nezlepšoval. To znamená, že ďalšie pridanie generácií by už nezlepšilo úspešnosť a keď áno, tak len minimálne. Takýto počet generácií by sa našiel pre bežné uzly a aj pre JVM uzly. Zaujímavé by to bolo z toho dôvodu, lebo by to mohla byť potencionálna silná stránka JVM uzlov, keďže dokážu vytvoriť zložitejšie obvody ako bežné uzly. Avšak vykonanie takéhoto experimentu by bolo dosť časovo náročné, hlavne pri JVM uzloch, keďže už výpočty pri 30000 generáciách trvajú mnohonásobne dlhšie ako výpočty pre bežné uzly. Takže jediný spôsob ako toto otestovať, je zmeniť implementáciu JVM uzlov tak, aby jeden beh s týmito uzlami bol rýchlejší.

Ďalší ukázaný experiment bol ten, ktorý používal bytecode zo šifrovacej funkcie AES. Výsledky tohoto experimentu skončili veľmi podobne ako ostatné výpočty, teda podobnými výsledkami ako dosiahol EACirc s bežnými uzlami, avšak o trochu horšími. Tu sa však ukázali zaujímavé výsledky pre funkciu \textit{Decim}, kde dosiahol EACirc s bytecodom z funkcie AES približne dvakrát lepšie výsledky ako EACirc s ostatnými bytecodmi. Preto by bolo veľmi zaujímavé zistiť, prečo je AES úspešnejší. Toto by sa dalo vykonať hľadaním rozdielu medzi bytecodmi AES-u a ostatných funkcií. Z toho by sa dalo vydedukovať, čo genetike pomáha pri hľadaní lepších obvodov. Či sa jedná o chýbajúcu inštrukciu, ktorú AES obsahuje a ostatné bytecody nie, alebo sa najčastejšie používaná inštrukcia z AES-u vyskytuje v ostatných bytecodoch len veľmi zriedka atď. V konečnom dôsledku by sa dal vytvoriť bytecode len z najčastejšie používanými inštrukciami pre konkrétnu funkciu, ktorý by mohol mať lepšiu úspešnosť. Avšak toto by bolo v rozpore so základnou myšlienkou pre JVM simulátor, pretože predpokladom je, že bytecode sa len jednoducho vytvorí z kryptografickej funkcie, poskytne sa EACircu, a on spraví všetku prácu, čo sa týka vyberania tých správnych inštrukcií. Naneštastie zatiaľ to vyzerá tak, že genetika má problém so skladaním týchto obvodov, aspoň pri bežnom nastavení, aké sme použili.

Tu sa dostávame k otázke, či ponechať bytecode, ktorý sme získali z funkcie v celku, alebo pomôcť genetike a bytecode nejakým spôsobom upraviť. Existujú nástroje, ktoré dokážu hľadať v bytecode zmysluplné časti. V kombinácii so spúšťaním celých funkcií z bytecodu, by sme získali obvody čo vykonávajú zmysluplnejšiu funkcionalitu, avšak taký istý efekt by sme dosiahli, keby sme jednoducho vytvorili nové uzly kde každý by obsahoval tento kus inštrukcií. Zautomatizovanie celého tohoto procesu by nebolo jednoduché, pretože by bolo treba začleniť už spomenutý nástroj do frameworku EACirc, tak aby stále platilo to, že EACirc dostane bytecode z kryptografickej funkcie a sám si vyberie inštrukcie, ktoré má v uzloch použiť. 



 

