\chapter{Experimenty}
\label{chap:experiments}

Hlavným cieľom zavedenia JVM uzlov bolo vylepšiť úspešnosť EACircu. Na otestovanie sme preto museli vyskúšať viacero experimentov, ktoré si predstavíme v tejto kapitole, a porovnať ich výsledky s výsledkami, ktoré dosiahol EACirc s bežnými uzlami, pri rovnakých nastaveniach. 

Autorom výsledkov z EACircu s bežnými uzlami, nie som ja, ale Ľubomír Obrátil, ktorému by som sa chcel za výsledky poďakovať.

\section{Experiment s imitáciou bežných uzlov}
\label{sec:exp1}

Prvý experiment slúžil najme na overenie, či JVM simulátor funguje korektne. Myšlienkou bolo na začiatok nepoužívať bytecode vytvorený z implementácie šifrovacej funkcie, ale skúsiť vytvoriť bytecode, ktorý bude napodobňovať bežné uzly, ktoré sa nachádzajú v EACircu. Očakávané boli podobné výsledky ako dosiahol štandardný EACirc.

\subsection{Použitý bytecode}
\label{subsec:exp1-bytecode}

Bytecode pre tento experiment sme museli napísať ručne, pretože si to vyžadovalo zamyslenie sa nad tým ako funguje každá jedna funkcia z bežných uzlov. Nie pri všetkých funkciách to bolo jednoduché, pretože prístup JVM simulátora je odlišný od prístupu bežných uzlov. 

Najväčší problém bol, že bežné uzly vykonávajú medzi všetkými vstupmi operáciu, napríklad \textit{AND, OR, XOR} atď. V prípade JVM simulátora nie je problém nájsť inštrukcie, ktoré plnia ekvivalentnú funkciu ako bežné uzly. Problém je, že bežné uzly vykonajú operáciu vždy medzi všetkými vstupmi, zatiaľ čo JVM simulátor vykoná náhodné množstvo inštrukcií, preto bolo treba premyslieť, ako ich vykonať dostatok na to, aby sa zvolená inštrukcia vykonala medzi všetkými vstupmi, teda medzi všetkými hodnotami na zásobníku. Tento problém sa dal vyriešiť tým, že by sme vykonávali vždy všetky inštrukcie funkcie, avšak toto riešenie by by bolo v rozpore so základnou myšlienkou JVM simulátora, a tou je vykonávať náhodný kus inštrukcií zo šifrovacej funkcie. Preto sme sa snažili aspoň zvýšiť pravdepodobnosť, že sa vykoná aspoň taký počet inštrukcií aký potrebujeme, a to tak, že sme pre každý typ bežného uzlu vytvorili v bytecode funkciu, a do nej vložili viac krát konkrétnu inštrukciu, a spoliehame sa na genetiku, že si vyberie dostatok inštrukcií na spracovanie všetkých hodnôt na zásobníku.

S týmto súvisí aj to že niektoré funkcie sa nedajú nahradiť jedinou ekvivalentnou inštrukciou, napríklad \textit{ROTL} alebo \textit{ROTR}, ktoré vykonávajú pravú respektíve ľavú rotáciu, ich implementácia obsahuje viac rôznych inštrukcií. V tomto prípade takisto nemôžeme garantovať, že sa vykoná celá funkcia, preto lebo začíname emuláciu od náhodného riadka. Dalo by sa to vyriešiť vykonávaním vždy všetkých inštrukcií vo funkcii, avšak toto riešenie by bolo v rozpore z našou predstavou ako by mal JVM simulátor fungovať, teda vykonávať v uzloch náhodný kus inštrukcií zo šifrovacej funkcie. 

Ďalší problém, ktorého výskyt sa ešte znásobil pri použití funkcií, ktoré vykonávajú náhodné množstvo rovnakých inštrukcií, teda potrebujú minimálne toľko hodnôt na zásobníku, aký je ich počet, je čo spraviť ak je na zásobníku nedostatočný počet hodnôt. Inými slovami čo spraviť ak potrebujeme vybrať hodnotu z prázdneho zásobníka. Z tohoto dôvodu sme museli upraviť implementáciu z nasledujúcimi možnosťami.

\begin{myItemize}
 \item \textbf{Pri vyberaní hodnoty z prázdneho zásobníka vracať 0}\\Avšak toto riešenie sa ukázalo ako nesprávne, pretože napríklad pre inštrukciu \textit{AND}, platí, že ak vykonáme túto operáciu s 0, výsledok bude vždy 0. To znamená, že v prípade jednej hodnoty na zásobníku, vyberáme dve hodnoty zo zásobníka, z toho druhá hodnota už bude 0 a vykonávame \textit{AND} s 0 a strácame celý doterajší výpočet.
 \item \textbf{V prípade prázdneho zásobníka vracať neutrálnu hodnotu}\\Tento spôsob by vyriešil problém predchádzajúceho riešenia, pretože v prípade, že sa vyberá z prázdneho zásobníka vracala by sa taká hodnota, s použitím ktorej by sa operácia správala ako identita, teda by vrátila vždy hodnotu prvého argumentu. Avšak nevýhodou je, že implementácia takéhoto riešenia, by bola zložitejšia a taktiež je zbytočné vykonávať niečo, čo aj tak nebude mať žiadny dôsledok. 
 \item \textbf{Preskakovať inštrukcie, ktoré nemajú dostatok hodnôt na zásobníku}\\Toto riešenie sa ukázalo ako najlepšie aj čo sa týka výkonu, pretože sa nepočítajú zbytočné výpočty, aj čo sa týka vyriešenia pôvodného problému.  
\end{myItemize}

\subsection{Výsledky experimentu}
\label{subsec:exp1-results}

Takto vytvorený bytecode sme použili na rozlíšenie medzi náhodnými dátami a hašovacou funkciou Tangle. Výsledky nepochádzajú z poslednej verzie JVM simulátora, pretože sme ich počítali už pár mesiacov pred napísaním tejto práce. Sivé zafarbenie bunky znamená, že EACirc bol úspešný vo viac prípadoch ako je hladina významnosti, teda 5\%, to znamená číslo vo vnútri bunky je väčšie ako 0.05. Je otázne, či takto označovať aj bunky, ktoré majú tesne nad 5\%, napríklad 0.55 alebo 0.6, pretože sa môže jednať aj o štatistickú odchýlku, preto sme sa rozhodli, že takto budeme označovať len bunky, ktoré budú mať hodnotu nad 0.07. 
 
\vspace{1em}
 \begin{table}[h]
\begin{tabularx}{\textwidth}{|C||C|C|C|}
	\hline
	\multicolumn{4}{|c|}{\textbf{Výsledky pre hašovaciu funkciu Tangle}} \\
	\hline \hline
	\vspace{0.1em}
	\textbf{Počet rúnd} &
	\vspace{0.1em}
	\begin{tabular}[b]{@{}c}\large\textbf{Bežné uzly} \\ \scriptsize(30000 generácií) \end{tabular} &
	
	\vspace{0.1em}
	\begin{tabular}[b]{@{}c}\large\textbf{JVM simulátor} \\ \scriptsize(30000 generácií) \end{tabular} &
		\vspace{0.1em}
		\begin{tabular}[b]{@{}c}\large\textbf{JVM simulátor} \\ \scriptsize(300000 generácií) \end{tabular} \\
	\hline\hline
	21 & 0.944\cc & 0.270\cc & 0.461\cc \\
	\hline
	22 & 0.932\cc & 0.267\cc & 0.465\cc \\
	\hline
	23 & 0.066 & 0.036 & 0.050 \\
	\hline
	
\end{tabularx}
\caption{Výsledky pre hašovaciu funkciu Tangle pri použití rôznych uzlov.}
\label{tab:exp1}
\end{table}

Z výsledkov vyplýva, že JVM simulátor síce dokázal rozoznať tie isté rundy ako bežné uzly, avšak s menšou istotou. To znamená, napríklad pre rundu 21, že zatiaľ čo bežné uzly boli schopné v 94\% prípadoch nájsť hľadaný obvod, EACirc s JVM uzlami bol to isté schopný spraviť len v 27\% prípadoch. Dôvodom menšej úspešnosti sú zrejme nevyriešené problémy spomenuté vyššie.

Pri výpočte na 300000 generáciách bolo EACircu poskytnuté 10 krát viac času na hľadanie obvodu, čiže očakávame lepšie výsledky. Avšak ani v tomto prípade, nebol EACirc s JVM uzlami schopný dotiahnuť sa na výsledky, ktoré mali bežné uzly, preto sme sa rozhodli pokračovať v testovaní na ďalší experiment v ktorom už budú použité bytecody zo šifrovacích respektíve hašovacích funkcií.

\section{Experiment JVM simulátora na malom testbede}
\label{sec:exp2}

Malý testbed je označenie, ktoré používame v našom tíme, na pomenovanie niekoľkých funkcií, patria sem hašovacie funkcie zo sútaže na funkciu SHA-3: \textit{Tangle, Dynamic SHA, Dynamic SHA-2} a prúdová šifrovacia funkcia z kandidátov na funkciu eStream: \textit{Decim}. Experiment spočíval v tom, že sme z týchto všetkých funkcií vytvorili bytecode a spustili všetky kombinácie výpočtov. Teda každú funkciu v kombinácii s každým bytecodom. Motivácia za týmto experimentom je zistiť, či bude EACirc úspešnejší, keď bude v uzloch, pomocou JVM simulátora, vykonávať inštrukcie zo skúmanej šifrovacej funkcie. 

\section{Použité bytecody}
\label{sec:exp2-bytecode}

Naneštastie sa nám nepodarilo nájsť implementáciu ani jednej z týchto funkcií v Jave, preto sme museli vytvoriť vlastnú. Najjednoduchšie riešenie pre nás bolo prepísať implementáciu z C++, ktorá je dostupná napríklad aj priamo v EACircu, do Javy. K prepisu nám pomohla voľná verzia konvertoru~\parencite{c++-java-converter} z C++ do Javy, od spoločnosti \textit{Tangible Software Solutions Inc}. Po konvertovaní sme museli ešte manuálne upraviť Java súbor tak, aby bol kompilovateľný, pretože niektoré konštrukcie z C++ sa nedali automaticky skonvertovať do Javy, napríklad práca s pamäťou alebo smerníková aritmetika. Takáto implementácia by pravdepodobne nebola funkčná ani korektná, ale na naše účely, teda na využitie inštrukcií, je postačujúca. 

Takto vytvorenú implementáciu sme potom jednoducho skompilovali a zo skompilovaného súboru získali konkrétne inštrukcie. Vzniknutý súbor s bytecodom bolo treba jemne upraviť, aby si s ním poradila funkcia na načítavanie bytecodu, ktorú obsahuje JVM simulátor, napríklad vymazať niektoré tabulátory a podobne. Posledným krokom bolo implementovanie inštrukcií, ktoré JVM simulátor zatiaľ nepoznal, pretože inak by načítavanie zlyhalo.

\section{Výsledky experimentu}
\label{sec:exp2-results}

Pre každú funkciu z malého testbedu, sme spočítali 3 rundy, konkrétne poslednú rundu, ktorú zvládne EACirc s bežnými uzlami plus nasledujúca a predchádzajúca. Ďalej sme pre každú rundu sme spočítali kombináciu s každým bytecodom, dohromady teda 4 výpočty na každú rundu, pretože máme 4 bytecody. To znamená, že dohromady sme mali 12 rôznych výpočtov pre každú funkciu. Každý z 12-tich výpočtov sme spustili 1000 krát to znamená dovedna sme mali pre jednu funkciu 12000 behov EACircu. Výpočty sme počítali na metacentre~\parencite{metacentrum}, kde sa behy spúšťajú v rámci tzv. úloh. V rámci jednej úlohy sme vypočítali 8 behov za menej ako dva dni, záležalo na akom stroji sa úloha počítala, niektoré zvládli všetkých 8 behov za 10 hodín a niektorým to trvalo aj 30 hodín. To znamená, že sme potrebovali pre jednu funkciu spočítať 1500 úloh, čo sme boli schopný vďaka metacentru urobiť za 2 až 3 dni, pretože nám naraz priradili až 800 strojov. 

Pre výsledky platí to isté čo v predchádzajúcom experimente, šedo podfarbené bunky znamenajú, že EACirc bol úspešný a našiel obvod vo viac ako 5\% prípadov, plus štatistická odchýlka.

\resultsTable
{Výsledky pre funkciu Tangle}
{
	21 & 0.944\cc & 0.605\cc & 0.609\cc & 0.643\cc & 0.453\cc \\
	\hline
	22 & 0.932\cc & 0.640\cc & 0.606\cc & 0.666\cc & 0.461\cc \\
	\hline
	23 & 0.066 & 0.045 & 0.058 & 0.040 & 0.051 \\
}
{Výsledky pre funkciu Tangle, prvý riadok určuje aký bytecode bol použitý.}
{tab:exp2-tangle}



\resultsTable
{Výsledky pre funkciu Dynamic SHA}
{
	7 & 1.000\cc & 0.996\cc & 0.998\cc & 1.000\cc & 0.899\cc \\
	\hline
	8 & 1.000\cc & 1.000\cc & 1.000\cc & 1.000\cc & 0.631\cc \\
	\hline
	9 & 1.000\cc & 1.000\cc & 1.000\cc & 1.000\cc & 0.616\cc \\
}
{Výsledky pre funkciu Dynamic SHA, prvý riadok určuje aký bytecode bol použitý.}
{tab:exp2-dynamic-sha}

Výpočet z \hyperref[tab:exp2-dynamic-sha]{tabuľky 4.3} je trochu prekvapivý, pretože EACirc je schopný rozlíšiť všetky rundy funkcie \textit{Dynamic SHA}, zatiaľ čo štatistické sady (\hyperref[chap:statistic-tests]{kapitola 1.}) sú schopné rozoznať funkciu len po rundu 7. Štatistické testy boli spustené nad dátami, ktoré vygeneroval generátor, ktorý obsahuje EACirc, z toho vyplýva, že chybu generátora môžeme vylúčiť. To znamená, že buď je funkcia zlá v niečom čo štatistické testy netestujú, alebo sa v implementácii EACircu nachádza chyba, ktorú sme prehliadli. 

\resultsTable
{Výsledky pre funkciu Dynamic SHA-2}
{
	10 & 1.000\cc & 1.000\cc & 1.000\cc & 1.000\cc & 1.000\cc \\
	\hline
	11 & 0.986\cc & 0.967\cc & 0.877\cc & 0.901\cc & 0.753\cc \\
	\hline
	12 & 0.059 & 0.056 & 0.042 & 0.057 & 0.053 \\
}
{Výsledky pre funkciu Dynamic SHA-2, prvý riadok určuje aký bytecode bol použitý.}
{tab:exp2-dynamic-sha-2}

\resultsTable
{Výsledky pre funkciu Decim}
{
	4 & 0.998\cc & 0.137\cc & 0.209\cc & 0.203\cc & 0.114\cc \\
	\hline
	5 & 0.802\cc & 0.073\cc & 0.095\cc & 0.079\cc & 0.053 \\
	\hline
	6 & 0.065 & 0.045 & 0.046 & 0.056 & 0.048 \\
}
{Výsledky pre funkciu Decim, prvý riadok určuje aký bytecode bol použitý.}
{tab:exp2-decim}

Výsledky z tabuliek \hyperref[tab:exp2-tangle]{4.2} až \hyperref[tab:exp2-decim]{4.5}, sú jemne chaotické, nenašli sme v nich žiadnu spojitosť medzi skúmanou funkciou a bytecodom z tej istej funkcie. Ba dokonca ani jeden z bytecodov sa nedá vyhlásiť za najlepší. Avšak pozitívne je, že narozdiel od \hyperref[sec:exp1]{experimentu 1} dosiahli JVM uzly porovnateľné výsledky vo väčšine prípadov, ako bežné uzly. Najhoršie výsledky sme dosiahli v prípade funkcie Decim, preto sme sa rozhodli, že na tejto funkcii vyskúšame výpočty s viac generáciami. Počet generácií sme zvolili na 300000, to znamená, že každý beh EACircu, bude trvať 10 násobne dlhšie. Z dôvodu veľmi dlhého výpočtu, sme museli znížiť počet behov z 1000 na 400. 

\begin{table}[ht]
	
	\renewcommand{\arraystretch}{1.2}
	
	\begin{tabularx}{\textwidth}{|C||C|C|C|C|}
		\hline
		\multicolumn{5}{|c|}{\textbf{Výsledky pre Decim s použitím 300000 generácií}} \\
		\hline \hline
		\vspace{5pt}
		\textbf{Runda} &
		\vspace{0pt}
		\begin{tabular}[b]{@{}c}\small\textbf{Tangle} \\ \scriptsize(proportion) \end{tabular} &
		\vspace{-10pt}
		\begin{tabular}[b]{@{}c}\small\textbf{Dynamic} \\ \small\textbf{SHA} \\ \scriptsize(proportion) \end{tabular} &
		\vspace{-10pt}
		\begin{tabular}[b]{@{}c}\small\textbf{Dynamic} \\ \small\textbf{SHA-2} \\ \scriptsize(proportion) \end{tabular} &
		\vspace{0pt}
		\begin{tabular}[b]{@{}c}\small\textbf{Decim} \\ \scriptsize(proportion) \end{tabular} \\
		\hline\hline
		4 & TBD & TBD & TBD & TBD \\
		\hline
		5 & TBD & TBD & TBD & TBD \\
		\hline
		6 & TBD & TBD & TBD & TBD \\
		\hline
		
	\end{tabularx}
	\caption{Výsledky pre funkciu Decim s použitím 300000 generácií, prvý riadok určuje aký bytecode bol použitý.}
	\label{tab:exp2-decim-300k}
\end{table}

\hyperref[tab:exp2-decim-300k]{Tabuľka 4.6} neobsahuje výsledky pre bežné uzly, pretože bežné uzly sme nepočítali na 300000 generácií, výsledky sa dajú porovnať s výsledkami z \hyperref[tab:exp2-decim]{tabuľky 4.5}, konkrétne stĺpec z označením bežné uzly, avšak treba brať na vedomie, že bežné uzly mali na hľadanie obvodu 10-krát menej času.

Zhrnutie výsledkov, po dopočítaní výpočtov.

\section{Výpočty so zložitejším bytecodom}
\label{sec:exp3}

Ďalší a zároveň posledný experiment, ktorý sme vyskúšali, bolo použiť v JVM simulátore bytecode, ktorý obsahuje zložitejšie konštrukcie. Otázkou teda je, či bude genetika schopná využiť takéto konštrukcie na zhotovenie lepších obvodov. Na vytvorenie bytecodu sme použili implementáciu šifrovacej funkcie AES~\parencite{AES-FIPS}.

Nastavenia pre tento experiment, boli rovnaké ako v \hyperref[sec:exp2]{experiemente 2.} teda 30000 generácií, 1000 testovacích vektorov a 1000 behov. Takisto sme pre funkciu Decim spočítali aj verziu s 300000 generáciami a 400 behmi. 
	\begin{table}[ht]
\twoColumns{		
		\renewcommand{\arraystretch}{1.2}
		
		\begin{tabularx}{7.3cm}{|C||C|}
			\hline
			\multicolumn{2}{|c|}{\textbf{Tangle}} \\
			\hline \hline
	
			\textbf{Runda} &
	
			\textbf{Proportion} \\
			\hline\hline
			21 & 0.574\cc \\
			\hline
			22 & 0.578\cc \\
			\hline
			23 & 0.049  \\
			\hline
			
		\end{tabularx}
		\caption{Výsledky pre funkciu Tangle s použitím bytecodu z funckie AES.}
		\label{tab:exp3-tangle}
		
		\begin{tabularx}{7.3cm}{|C||C|}
			\hline
			\multicolumn{2}{|c|}{\textbf{Dynamic SHA-2}} \\
			\hline \hline
			
			\textbf{Runda} &
			
			\textbf{Proportion} \\
			\hline\hline
			10 & 1.000\cc \\
			\hline
			11 & 0.957\cc \\
			\hline
			12 & 0.056  \\
			\hline
			
		\end{tabularx}
		\caption{Výsledky pre funkciu Dynamic SHA-2 s použitím bytecodu z funckie AES.}
		\label{tab:exp3-dynamic-sha-2}
}{
		\renewcommand{\arraystretch}{1.2}
		
		\begin{tabularx}{7.3cm}{|C||C|}
			\hline
			\multicolumn{2}{|c|}{\textbf{Dynamic SHA}} \\
			\hline \hline
			
			\textbf{Runda} &
			
			\textbf{Proportion} \\
			\hline\hline
			7 & 0.977\cc \\
			\hline
			8 & 0.985\cc \\
			\hline
			9 & 0.992\cc  \\
			\hline
			
		\end{tabularx}
		\caption{Výsledky pre funkciu Dynamic SHA s použitím bytecodu z funckie AES.}
		\label{tab:exp3-dynamic-sha}
		
		\begin{tabularx}{7.3cm}{|C||C|}
			\hline
			\multicolumn{2}{|c|}{\textbf{Decim}} \\
			\hline \hline
			
			\textbf{Runda} &
			
			\textbf{Proportion} \\
			\hline\hline
			4 & 0.640\cc \\
			\hline
			5 & 0.187\cc \\
			\hline
			6 & 0.056  \\
			\hline
			
		\end{tabularx}
		\caption{Výsledky pre funkciu Decim s použitím bytecodu z funckie AES.}
		\label{tab:exp3-decim}
}

	\vspace{15pt}
	\begin{tabularx}{\textwidth}{|C||C|}
		\hline
		\multicolumn{2}{|c|}{\textbf{Decim - 300000 generácií}} \\
		
		\hline \hline
		
		\textbf{Runda} &
		
		\textbf{Proportion} \\
		\hline\hline
		4 & TBD \\
		\hline
		5 & TBD \\
		\hline
		6 & TBD  \\
		\hline
		
	\end{tabularx}
	\caption{Výsledky pre funkciu Decim s použitím bytecodu z funckie AES a počtom generácií 300000.}
	\label{tab:exp3-decim-300k}

\end{table}

Z tabuliek \hyperref[tab:exp3-tangle]{4.7} až \hyperref[tab:exp3-decim-300k]{4.11} vyplýva, že EACirc s bytecodom z funkcie AES sa úspešnosťou vyrovnáva použitím bytecodu z funkcií v predchádzajúcom \hyperref[sec:exp2]{experimente} až na funkciu Decim kde je výrazne lepší, avšak stále sa nevyrovnáva úspešnosti bežných uzlov (\hyperref[tab:exp2-decim]{tabuľka 4.5}). Z toho vyplýva, že môžeme potvrdiť, že použitie zložitejšieho bytecodu je pre genetiku v niektorých prípadoch výhodné.






















