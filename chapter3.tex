\chapter{Simulátor Java bytecodu}
\label{chap:eacirc-jvmsim}

V tejto kapitole si predstavíme nový typ uzlov, ktoré nevykonávajú iba jednoduchú funkcionalitu (napr. \textit{AND, OR, XOR}), ale emulujú časť z dissasemblovaného Java bytecodu. Tieto uzly vznikli za účelom pomôcť genetike, aby mohla čo najjednoduchšie vytvoriť výsledný obvod, ktorý bude mať čo najlepšiu úspešnosť. Základná myšlienka je taká, že obvod, ktorý v uzloch vykonáva inštrukcie, ktoré boli vybrané z implementácie kryptografickej funkcie, by mal mať vyššiu šancu rozlíšiť medzi náhodnými dátami a výstupom z tejto funkcie ako EACirc s bežnými uzlami. Jedným z hlavných cieľov tejto bakalárskej práce je overiť, či je táto myšlienka pravdivá. 

\section{Motivácia za použitím Java bytecodu}
\label{sec:java-bytecode}

Java je na jednu stranu vysoko úrovňový jazyk, čo znamená, že je jednoduchší na učenie a tým pádom aj rozšírenejší, no na druhú stranu je jednoduché z neho dostať nízko úrovňový binárny kód, ktorý sa dá interpretovať. Vďaka jej rozšírenosti  by mala byť samozrejmosťou dostupnosť implementácie množstva pseudo náhodných generátorov a šifrovacích funkcií. Z tohoto pohľadu sa Java javí ako veľmi dobrý jazyk pre použitie popísané v tejto kapitole.

\section{Vysvetlenie skratky JVM (Java Virtual Machine)}
\label{sec:jvm}

JVM~\parencite{JVM} je software, čo spája kód naprogramovaný v Jave a hardware konkrétneho počítača, na ktorom tento kód spúšťame. Vďaka nemu je Java multiplatformová, pretože Javu je možné spustiť všade tam, kde beží JVM. Samotný JVM má podobné princípy ako bežný procesor, teda napríklad obsahuje zásobník, registre a vie vykonávať konečnú množinu inštrukcií.

Fungovanie JVM nie je nič zložitého, jednoducho obsahuje implementáciu všetkých inštrukcií a po načítaní bytecodu vykonáva jednu inštrukciu po druhej. Avšak poznať detailné fungovanie JVM nie je pre účely našej práce dôležité. Dôležité je vedieť, že aj nás JVM simulátor vykonáva inštrukcie z bytecodu. Avšak s tým rozdielom, že vykonáva náhodný kus inštrukcií, vykonáva ich v rámci uzlov EACircu a nepozná úplne všetky inštrukcie, ktoré obsahuje klasický JVM. Implementované sú zatiaľ iba tie inštrukcie s ktorými sme sa stretli v niektorom z použitých bytecodov a boli v rámci nášho simulátora implementovateľné. Ďalší rozdiel je napríklad v používaní zásobníka, v klasickom JVM má každá funkcia svoj vlastný lokálny zásobník, ktorý sa používa napríklad na predávanie argumentov, lokálne premenné atď. zatiaľ čo náš simulátor používa zásobník ako globálne úložisko, na ktoré sa ukladajú hodnoty počas celého jedného výpočtu, prislúchajúceho jednému uzlu.  

\subsection{Bytecode}
\label{subsec:bytecode}

Bytecode je označenie pre súbor, ktorý je výstupom po skompilovaní Java kódu. Má presne danú štruktúru, ktorú vie vykonávať každý JVM. Je to v podstate množina funkcií, kde každá funkcia obsahuje niekoľko inštrukcií. Každý riadok s inštrukciou obsahuje číslo inštrukcie, názov inštrukcie, prípadne argumenty pre inštrukciu. Napríklad inštrukcia \textit{bipush} berie ako argument číslo, ktoré vloží na zásobník. 

\section{Princíp fungovania emulácie}
\label{sec:jvm-principle}

Fungovanie JVM simulátora je proces, ktorý sa skladá z viacerých bodov, avšak nie je to súvislý proces, jedná sa iba o obsluhu JVM uzlov. Zvyšok EACircu funguje tak ako pri bežných uzloch. V tejto kapitole si prejdeme celý proces krok po kroku, od zvolenia uzlu za JVM uzol až po vykonávanie konkrétnych inštrukcií a výpočet výsledku. 

\subsection{Načítavanie bytecodu}
\label{parsing-bytecode}

Na začiatku behu EACircu sa musí JVM simulátor nainicializovať, čoho súčasťou je načítavanie bytecodu zo súboru. Funkcie a inštrukcie z tohoto súboru sa budú používať počas celého jedného behu. Jeho názov je uložený v konfiguračnom súbore v elemente \textit{JVM\_FILENAME}. Každá funkcia je následne uložená v spojovanom zozname a má priradené unikátne číslo a jej prislúchajúce inštrukcie. Takýmto spôsobom sa postupne načíta celý bytecode. Ak sa pri načítavaní vyskytne nejaká chyba, napríklad neznáma inštrukcia alebo zlá štruktúra bytecodu, vypíše sa chyba a vykonávanie programu skončí.

V bytecode existuje množstvo inštrukcií. Niektoré z inštrukcií vyžadujú na svoje vykonanie aj argumenty, preto sa v štruktúre nachádza aj možnosť uloženia až dvoch argumentov.

\subsection{JVM uzly a voľba parametrov}
\label{subsec:jvm-nodes}

Každý uzol v súčasnej implementácií EACircu obsahuje 4 Bytovú informáciu (\hyperref[sec:nodes]{sekcia 2.3}). JVM uzol využíva celé 4 Byty a to nasledovne: \vspace{0pt}

\begin{myItemize}
	\item 1. Byte: tu je uložené, že sa jedná o JVM uzol, v súčastnosti číslo 19,
	\item 2. Byte: číslo funkcie, ktorej inštrukcie sa budú vykonávať,
	\item 3. Byte: číslo riadka, na ktorom sa nachádza inštrukcia, od ktorej sa začína výpočet,
	\item 4. Byte: počet inštrukcií, koľko sa má vykonať. To znamená, že sa vykonávajú inštrukcie od tej na riadku z parametru číslo 3 po inštrukciu na riadku, ktorý vznikne spočítaním 3. a 4. parametra. Toto obmedzenie však neplatí pri vykonávaní funkcie zavolanej špeciálnymi inštrukciami \textit{INVOKE} (viac v \hyperref[subsec:emulating-ins]{podsekcii 3.3.3}). Medzi inštrukcie \textit{INVOKE} patria: \textit{INVOKESPECIAL, INVOKESTATIC, INVOKEVIRTUAL}. 
\end{myItemize}

Pri tvorbe obvodu sa pri každom uzle EACirc náhodne rozhoduje, akú funkciu bude plniť. Do EACircu bola doplnená funkcia, ktorá sa volá v prípade, že voľba vyberie, že sa jedná o JVM uzol. Táto funkcia do uzla dopĺňa parametre, popísané vyššie. Parametre sa síce volia náhodne, ale pre zvolené hodnoty musí platiť, že uzol z nich vytvorený, je validný. To znamená funkcia s číslom v parametri 2 musí existovať aj so začiatočnou inštrukciou a dostatkom inštrukcií na vykonávanie podľa posledných dvoch parametrov.

\subsection{Vykonávanie inštrukcií} 
\label{subsec:emulating-ins}

Tak ako reálny Java virtual machine aj JVM simulátor obsahuje zásobník. Na začiatku sa naň vložia všetky vstupy, ktoré vykonávaný uzol má. Okrem zásobníka obsahuje aj štruktúru, ktorá určuje stav procesora, teda ktorá funkcia sa vykonáva a na ktorom riadku. Pri požiadavke na vykonanie JVM uzlu sa najprv vyplní táto štruktúra tak, že obsahuje pointer na funkciu a číslo prvej inštrukcie, ktoré sa vybralo z 3 parametru uzlu. Následne sa v slučke emulujú všetky ostatné inštrukcie, s tým, že po každom úspešnom behu sa číslo inštrukcie zdvihne o jedna. 

Existujú však aj špeciálne inštrukcie, po vykonaní ktorých sa nepokračuje bežnou cestou, teda pokračovaním na ďalšiu inštrukciu. Napríklad inštrukcie, ktoré preskakujú na iné inštrukcie v rámci funkcie. Sú to inštrukcie začínajúce na \textit{IF} teda napríklad: \textit{IFEQ, IFNE, IFGE} alebo \textit{IFLE}. Tieto inštrukcie slúžia na vetvenie programu, kde sa po splnení podmienky skáče na konkrétnu inštrukciu, ktorej číslo sa nachádza v argumente inštrukcie. Ďalšia inštrukcia, ktorá skáče v rámci funkcie je \textit{GOTO}, avšak narozdiel od inštrukcií \textit{IF} skáče automaticky, bez kontrolovania podmienky. Ďalšie špeciálne inštrukcie sú tie začínajúce na \textit{INVOKE}, ktoré slúžia na volanie ostatných funkcií, ktoré obsahuje bytecode. Po vykonaní všetkých inštrukcií v zavolanej funkcií sa pokračuje na ďalšiu inštrukciu, ktorá nasleduje po inštrukcii \textit{INVOKE}. 

\subsection{Výsledok uzlu}

Po vykonaní všetkých inštrukcií sa ako výsledok uzla berie \textit{XOR} hodnôt na zásobníku. 

\section{Problémy spojené s implementáciou}
\label{sec:problems}

Jeden z problémov v súčasnej implementácií je nemožnosť uložiť do uzlu viac ako 4B informácie. Keďže prvý Byte je rezervovaný na funkciu, pre naše účely ostávajú iba 3 Byty. Po rozdelení máme teda pre každý z troch parametrov, spomenutých v \hyperref[subsec:jvm-nodes]{podsekcii 3.3.2} rozsah [0-255]. S týmto rozdelením sme schopní vykonať maximálne 255 inštrukcií, a zároveň začať maximálne na riadku 255. V bežnom prípade je teda posledná inštrukcia, ktorú dokážeme vykonať na riadku 510, čo znamená, že akákoľvek inštrukcia za ňou nemôže byť nikdy vykonaná. Avšak funkcie v bytecode majú často niekoľko násobne viac inštrukcií. V súčasnej dobe sa však prerába celá genetika v rámci EACircu a v novej implementácii by mal tento problém zaniknúť, pretože by malo byť v uzle viac miesta pre parametre.

S predchádzajúcim problémom súvisí aj časová náročnosť pri veľkom množstve vykonávaných inštrukcií. EACirc počas jedného behu spracuje veľké množstvo uzlov, preto časová náročnosť rastie pri väčšom množstve vykonávaných inštrukcií v rámci jedného uzlu veľmi rýchlo. Keďže môže nastať situácia, kedy sa v extrémnych prípadoch vykoná aj viac ako 255 inštrukcií, bolo potrebné limitovať celkový počet inštrukcií, ktoré sa môžu vykonať v rámci emulácie jedného uzlu, na 300. Situácia kedu sa môže vykonať viac ako 255 inštrukcií môže nastať napríklad kvôli inštrukcii \textit{GOTO}, kedy sa stáva že simulátor donekonečna preskakuje niekam nad aktuálnu inštrukciu a toto opakuje až kým sa nevyčerpá limit inštrukcií. Alebo pri inštrukciách \textit{INVOKE} v prípade, že sa zavolá funkcia, ktorá obsahuje priveľa inštrukcií.

\section{Implementačné rozdiely medzi skutočným JVM a našim JVM}
\label{sec:impl-diff}

Okrem rozdielu, že nevykonávame funkcie v bytecode ako celok, ale pre každý uzol vykonávame náhodný kus inštrukcií z náhodnej funkcie, je ďalším rozdielom neúplnosť implementácie inštrukcií v našom JVM simulátore. Dôvodom je, že nie všetky inštrukcie boli pre nás výhodné na implementáciu čo sa týka pomeru vynaloženého úsilia a pridanej hodnoty. Preto sa pri vykonávaní týchto inštrukcií nevykoná nič a tieto inštrukcie sa automaticky preskočia. Jednými z nich sú napríklad inštrukcie na prácu s poľami a objektami. Celý zoznam inštrukcií, ktoré JVM simulátor síce obsahuje, ale nemá ich implementované, je vypísaný v prílohe. 

\section{Výhody prístupu}
\label{sec:advantages}

Okrem výhody používať vo funkcii, ktorá je vytváraná za účelom rozlíšiť testované dáta od náhodných dát, priamo inštrukcie z ich generátora, je najväčšou výhodou možnosť skonštruovať naozaj komplexný obvod zložený zo zložitejších častí. Otázkou ale je, či je genetika natoľko silný nástroj, aby bola schopná zložiť takéto komplexné obvody, pretože s použitím JVM simulátora je naozaj mnohonásobne viac možností ako výsledný obvod poskladať. Preto je ďalšou otázkou aj to, či pre JVM obvody nie je potrebné viac času, a teda viac generácií na hľadanie výsledného obvodu.

\section{Nevýhody JVM uzlov}
\label{sec:disadvantages}

Najväčšou nevýhodou je dĺžka výpočtu, avšak takáto dĺžka je očakávateľná, pretože sa v uzloch vykonávajú časovo o dosť zložitejšie výpočty pri porovnaní s bežnými uzlami. Zatiaľ čo bežný uzol sa dá prirovnať k jednej vykonanej inštrukcii medzi všetkými vstupmi, JVM simulátor ich vykonáva v rámci jedného uzlu niekoľko násobne viac. S vykonávaním inštrukcií je spojená aj réžia, ako napríklad kontrola počtu hodnôt na zásobníku alebo kontrola prekročenia maximálneho počtu inštrukcií. Takže v konečnom dôsledku je jeden beh mnohonásobne dlhší, ako beh s bežnými uzlami.

Niektoré inštrukcie, napríklad \textit{IADD}, ktorá vyberie zo zásobníka dve čísla, spočíta ich a výsledok vloží na zásobník, vyžadujú niekoľko hodnôt na zásobníku, a nie vždy sa tam tieto hodnoty vyskytujú. Z tohoto dôvodu sa stáva, že sa inštrukcie musia preskočiť. To znamená, že ak je zásobník prázdny, žiadna inštrukcia vyžadujúca hodnoty na zásobníku sa nevykoná. Avšak tento nedostatok sa nedá vyriešiť jednoduchou cestou, pretože je spôsobený vykonávaním náhodných inštrukcií, mnohokrát aj zo stredu funkcie. Môže sa teda stať, že vo veľa uzloch sa nevykoná vôbec nič. Potencionálne však máme možnosť vytvoriť zložitý obvod aj keď niekoľko uzlov nerobí nič. Iný pohľad na vec je, že aj obvody, v ktorých je veľa takýchto uzlov, môžu mať v konečnom dôsledku vysokú úspešnosť čo sa týka rozoznávania náhodných dát, preto je len na genetike, aby si vybrala ten správny prístup. 
